# 1. 线程的互斥与同步
- 互斥：共享资源的互斥访问
- 同步：一个线程的执行需要等待另一个线程的完成

# 2. 互斥的管理办法
1. mutex互斥锁
2. shared_mutex读写锁：不经常更新的数据，即写得少，读得多
3. static（c++11）
## 2.1死锁
    std::lock() 可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)。
1. 避免嵌套锁
2. 避免在持有锁时调用用户提供的代码
3. 不同的线程使用固定顺序获取锁
4. 使用层次锁：每一个mutex都分配一个层级号码，并且严格按照下面两个规则：
    - 当占有层级为N的mutex的时候，只能去获取层次< N的mutex
    - 当试图同时占有多个同层级的mutex的时候，这些锁必须一次性获取，通过类似于std::lock的方法去保证顺序。


# 3. 同步的管理办法
- 条件变量（condition variables）
- 期望值（futures）

# 4. 线程池
