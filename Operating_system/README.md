# 
一个系统中的进程是与其他进程共享CPU和主存资源的。随着对CPU需求的增长，进程以某种合理的平滑的方式慢了下来。但是如果太多的进程需要太多的内存，那么它们中的一些就根本无法运行。当一个程序中没有空间可以用时，那就是它运气不好了。内存还容易被破坏。如果某个进程不小心写了另一个进程使用的内存，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。

为了更加有效的管理内存并且少出错，现代系统提供了一种对主存的抽象的概念，叫做虚拟内存（VM）。虚拟内存时硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每一个进程提供一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个很重要的能力：
1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，高效的使用了主存。
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理
3. 它保护了每个进程的地址空间不被其他进程破坏。
# 一.物理和虚拟寻址
    计算机系统的主存被组织成一个有M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（PA）。第一个字节的物理地址为0，接下来的字节地址为2，依次类推。给定这种简单的结构，CPU方位内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址（physical addressing）。

![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%89%A9%E7%90%86%E5%AF%BB%E5%9D%80%E7%9A%84%E7%B3%BB%E7%BB%9F.png)

    早期的PC使用的是物理地址，而且诸如数字信号处理器、嵌入式微控制器以及Cray超级计算机这样的系统仍然还是继续使用这种寻址方式。然而现代的处理器使用的是一种称为虚拟寻址（virtual address）的寻址方式。

![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80%E7%9A%84%E7%B3%BB%E7%BB%9F.png)

    使用虚拟地址，CPU通过生成一个虚拟地址（Virtual Address，VA）来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将这个虚拟地址转换成物理地址的任务叫做地址翻译（address translation）。就像异常处理一样，地址翻译需要CPU硬件和操作系统的紧密合作。CPU芯片上叫做内存管理单元（MMU）的专有硬件，利用存放主存中的查询表来动态的翻译虚拟地址，该表的内容由操作系统来管理。

# 二.地址空间
    地址空间是一个非负整数的有序集合{0，1，2，.......}。如果地址空间中的整数是连续的，那么我们说它是一个线性的连续地址空间。在一个带有虚拟内存的系统中，CPU从一个由N个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space）。一个地址空间的大小是由表示最大地址所需要的位数来描叙的。现代系统通常支持32位或者64位虚拟地址空间。
    一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的M个字节。地址空间的概念是十分重要的，因为它清楚地区分了数据对象（字节）和它们地属性（地址）。一旦认识到了这种区别，那么我们就可以将其推广了，允许每个数据对象有多个独立地地址空间，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟空间的虚拟地址和一个选自物理空间的物理地址。

# 三.虚拟内存作为缓存的工具
    概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存到主存中。和存储器层次结构中其他缓存一样，磁盘（较低层）上的数据被分割为块，这些块作为磁盘和主存之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页（Vitrual Page）的大小固定的块来处理这个问题。每个页面大小为P字节。类似的，物理内存页被分割为物理页（Physical page,PP）,大小也为P字节（物理页面也被称为页帧 Page frame）。
    在任何时刻，虚拟页面的集合都分为三个不相交的子集：
1. 未分配：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。
2. 缓存的：当前已缓存在物理内存中的已分配页。
3. 未缓存的：未缓存在物理内存中的已分配页。
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E4%B8%80%E4%B8%AAVM%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%BB%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84.png)
# 四.页表
    同任何缓存一样，虚拟内存系统必须由某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页面中。如果不命中，系统必须判断这个虚拟页面放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页面。
    这些功能是软硬件联合提供的，包括操作系统、MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫作页表（page table）的数据结构，页表将虚拟页映射到物理页面。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。
    下图展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry）的数组。虚拟地址空间中的每个页在页表中都有一个固定的偏移量处都有一个PTE。为了我们的目的，我们假设每个PTE是由一个有效位（valid bit）和一个n位地址字段组成的。有效位表明了该虚拟页面当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么这个空地址表示这个虚拟页还未被分配。否则，这个地址就会指向该虚拟页在磁盘上的起始位置。
![pagetable1](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E9%A1%B5%E8%A1%A81.png)
![pagetable2](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E9%A1%B5%E8%A1%A82.png)
![pagetable3](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E9%A1%B5%E8%A1%A83.png)




# 五.地址翻译
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%911.png)
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%912.png)
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%913.png)
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%914.png)


# 6.进程与线程
1. 进程是资源分配的最小单位，线程是cpu调度的最小单位
2. 一个程序至少有一个进程，一个进程至少有一个线程，多个线程共享所属进程的资源
3. 进程有自己的地址空间，线程只有栈和程序计数器和一组寄存器
4. 一个进程死掉不会影响其他进程，一个线程死掉会导致整个进程死掉
5. 进程间切换比线程的切换要慢

# 7.进程通信方式
1. 管道：半双工通信，数据只能单向流动。
    - 无名管道：与fork()联用，只能用于具有亲缘关系的进程之间通信。
    - 命名管道：创建FIFO文件，进行类似于linux文件的read和write操作进行通信，不需要进程间具有亲缘关系。需要留意进程间同步和阻塞问题
2. 消息队列：消息队列是一个消息链表由内核管理，可以区分消息类型
3. 信号：用于通知接受进程有某种事件发生,例子：Ctrl-C
4. 共享内存：速度最快，要互斥访问。使用shamget()函数创建一款共享内存，并使用shamat()函数将该共享内存映射到当前进程的虚拟地址空间。
5. 信号量：信号量是一个计数器，控制多个进程或线程间的同步与互斥。
6. 套接字

# 8. cpu调度方式
1. 先来先服务 first-come first-severd
2. 短作业优先 shortest job firs
3. 最短剩余时间优先 shortest remaining time first
4. 时间片轮转：一个队列，每次从队头取出一个进程执行一个时间片，然后放回队尾。 
5. 优先级调度
6. 多级反馈队列：多个队列，每个队列进行时间片轮转。多个队列按照优先级调度，新到达的进程首先放入优先级最高的队列，优先级最高的队列为空时才会调度优先级第二的队列，以此类推。当前进程完成时间片运行后放入次优先级的队列。

# 线程通信方式
1. 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
   - 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。
   - 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。
   - 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。
   - 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
2. 信号量机制(Semaphore)
   - 无名线程信号量
   - 命名线程信号量
3. 信号机制(Signal)：类似进程间的信号处理
4. 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。
- 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制