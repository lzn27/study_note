## 1 GameObject Pool
作用：降低频繁地创建与销毁对象对CPU的消耗。

## 2 unity 热更新
1. tolua
2. xlua
3. ILRuntime
4. InjectFix(iFix)

## 3 LockStep与非LockStep（帧同步状态同步（云风：翻译不准确））
https://blog.codingnow.com/2018/08/lockstep.html
- lockstep（帧同步）是按回合锁定游戏进程，逐步推演，关键在于lock。客户端根据内在的时钟稳定按 固定时间（例如：100ms） 的心跳步进。
- 状态同步：即不锁定步长，服务器只需要在游戏沙盘变化后，把新的状态同步给客户端，减少了带宽需求，客户端则不用严格等待服务器的步进，无论服务器有没有新的状态下发，也自行推测（或不推测，保留前一个状态）和模拟游戏沙盘。当服务器下发新状态时，修正客户端的表现即可。
- 中心服务器：权威主机，所有客户端把操作发往这个主机，由它来计算，然后把当前回合的计算结果：沙盘上每个单位的状态变化广播给所有客户端，一样可以得到一致的结果。权威服务器若有额外逻辑，比如 MOBA 战场上指挥一些 NPC 单位，这些额外的操作也应该用 frame 来驱动，而非时钟。即，要实现成在第 300 frame 时刷出一个 NPC ，而不能实现成在第 30 秒时刷出一个 NPC 。服务器大致保证一秒步进 10 个 frame 就够了，而不需要精确的保证这些 frame 在准确的时刻发生。对于游戏规则来说，只有每个 frame 发生了什么，而和真实时间是完全解耦的。
- 反作弊：在没有中心服务器的情况下：一般的做法是每个人的客户端同时计算出每个回合的所有单位的状态的一个 hash 值，如果发现自己算的和别人的不一致，就表示不一致。如果没有修改客户端的话，这一版是客户端本身的 bug 造成的。对于基于权威服务器的演算，客户端只有表现结果的职责，更无法改变结果。
