# 
一个系统中的进程是与其他进程共享CPU和主存资源的。随着对CPU需求的增长，进程以某种合理的平滑的方式慢了下来。但是如果太多的进程需要太多的内存，那么它们中的一些就根本无法运行。当一个程序中没有空间可以用时，那就是它运气不好了。内存还容易被破坏。如果某个进程不小心写了另一个进程使用的内存，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。

为了更加有效的管理内存并且少出错，现代系统提供了一种对主存的抽象的概念，叫做虚拟内存（VM）。虚拟内存时硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每一个进程提供一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个很重要的能力：
1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，高效的使用了主存。
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理
3. 它保护了每个进程的地址空间不被其他进程破坏。
# 一。物理和虚拟寻址
    计算机系统的主存被组织成一个有M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（PA）。第一个字节的物理地址为0，接下来的字节地址为2，依次类推。给定这种简单的结构，CPU方位内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址（physical addressing）。

![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%89%A9%E7%90%86%E5%AF%BB%E5%9D%80%E7%9A%84%E7%B3%BB%E7%BB%9F.png)

    早期的PC使用的是物理地址，而且诸如数字信号处理器、嵌入式微控制器以及Cray超级计算机这样的系统仍然还是继续使用这种寻址方式。然而现代的处理器使用的是一种称为虚拟寻址（virtual address）的寻址方式。

![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80%E7%9A%84%E7%B3%BB%E7%BB%9F.png)

    使用虚拟地址，CPU通过生成一个虚拟地址（Virtual Address，VA）来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将这个虚拟地址转换成物理地址的任务叫做地址翻译（address translation）。就像异常处理一样，地址翻译需要CPU硬件和操作系统的紧密合作。CPU芯片上叫做内存管理单元（MMU）的专有硬件，利用存放主存中的查询表来动态的翻译虚拟地址，该表的内容由操作系统来管理。

# 二。地址空间
    地址空间是一个非负整数的有序集合{0，1，2，.......}。如果地址空间中的整数是连续的，那么我们说它是一个线性的连续地址空间。在一个带有虚拟内存的系统中，CPU从一个由N个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space）。一个地址空间的大小是由表示最大地址所需要的位数来描叙的。现代系统通常支持32位或者64位虚拟地址空间。
    一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的M个字节。地址空间的概念是十分重要的，因为它清楚地区分了数据对象（字节）和它们地属性（地址）。一旦认识到了这种区别，那么我们就可以将其推广了，允许每个数据对象有多个独立地地址空间，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟空间的虚拟地址和一个选自物理空间的物理地址。

# 三。虚拟内存作为缓存的工具
    概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存到主存中。和存储器层次结构中其他缓存一样，磁盘（较低层）上的数据被分割为块，这些块作为磁盘和主存之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页（Vitrual Page）的大小固定的块来处理这个问题。每个页面大小为P字节。类似的，物理内存页被分割为物理页（Physical page,PP）,大小也为P字节（物理页面也被称为页帧 Page frame）。
    在任何时刻，虚拟页面的集合都分为三个不相交的子集：
1. 未分配：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。
2. 缓存的：当前已缓存在物理内存中的已分配页。
3. 未缓存的：未缓存在物理内存中的已分配页。
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E4%B8%80%E4%B8%AAVM%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%BB%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84.png)
# 四。页表
    同任何缓存一样，虚拟内存系统必须由某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页面中。如果不命中，系统必须判断这个虚拟页面放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页面。
    这些功能是软硬件联合提供的，包括操作系统、MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫作页表（page table）的数据结构，页表将虚拟页映射到物理页面。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。
    下图展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry）的数组。虚拟地址空间中的每个页在页表中都有一个固定的偏移量处都有一个PTE。为了我们的目的，我们假设每个PTE是由一个有效位（valid bit）和一个n位地址字段组成的。有效位表明了该虚拟页面当前是否被缓存在DRAM中。如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么这个空地址表示这个虚拟页还未被分配。否则，这个地址就会指向该虚拟页在磁盘上的起始位置。
![pagetable1](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E9%A1%B5%E8%A1%A81.png)
![pagetable2](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E9%A1%B5%E8%A1%A82.png)
![pagetable3](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E9%A1%B5%E8%A1%A83.png)




# 五。地址翻译
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%911.png)
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%912.png)
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%913.png)
![](https://github.com/lzn27/study_note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%914.png)


